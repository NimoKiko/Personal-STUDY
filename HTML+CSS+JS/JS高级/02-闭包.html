<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 
      1.如何产生闭包？
        当一个嵌套的内部函数引用了嵌套的外部函数的变量(函数)时，就产生了闭包
      2.闭包是什么？
        理解一：闭包是嵌套的内部函数
        理解二：包含被引用变量的对象
        注意：闭包存在于嵌套的内部函数中
      3.闭包产生的条件
     -->
    <script>
      function fn1() {
        var a = 2;
        function fn2() { //执行函数定义就会产生闭包（不用调用内部函数，但是外部函数需要定义）
          console.log(a);
        }
      }
      fn1();
      /*
        常见的闭包：
          1.将函数作为另一个函数的返回值
          2.将函数作为实参传递给另一个函数调用
        
        闭包的作用：
          1.使用函数内部的变量在函数执行完后，仍然存在内存中（延长了局部变量的生命周期）
          2.让函数外部可以操作（读写）到函数内部的数据（变量/函数）
        
        问题：
          1.函数执行完后，函数内部声明的局部变量是否还存在？
            一般是不存在，存在于闭包中的变量才可能存在
          2.在函数外部能直接访问函数内部的局部变量吗？
            不能，但是可以通过闭包让外部操作它
      */
     function fn3() {
      var a = 2;
      function fn4() {
        a++;
        console.log(a);
      }
      return fn4;
     }
     var f = fn3(); //这一步就是将内部函数保存下来了，这就是延长函数中局部变量生命周期的主要原因
     f();
     f();
     /*
      闭包的生命周期：
        1.产生：在嵌套的内部函数定义执行完成的时候就产生了（不是调用的时候才有）
        2.死亡：在嵌套的内部函数成为垃圾对象时
     */
     function fn5() {
      var a = 2;
      function fn6() {
        a++;
        console.log(a);
      }
      return fn6;
     }
     var f = fn5();
     f();
     f();
     f = null; //闭包死亡
     /*
      闭包的应用：自定义JS模块
        JS模块：
     */
    </script>
  </body>
</html>
